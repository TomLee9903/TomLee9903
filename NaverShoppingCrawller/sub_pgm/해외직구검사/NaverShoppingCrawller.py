# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
from typing import Text
from unittest import result
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import uic
from PyQt5 import QtCore
from PyQt5.QtCore import *
from PyQt5.QtCore import pyqtSlot

from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import chromedriver_autoinstaller
import time
import datetime
import os
import pandas as pd
from PyQt5 import QtCore, QtGui, QtWidgets
import threading
import openpyxl
import shutil
import subprocess
import urllib.request
import requests
import json
import re

# QT designer ui 파일 로드
form_class = uic.loadUiType("./driver/main_ui.ui")[0]

# UI 텍스트 출력 클래스
class TextBrowser(QThread):
    # signal을 MyWindow에 전달할 수 있게 하는 인자
    finished = pyqtSignal(str)
    now_date = ''

    @pyqtSlot(str)
    def run(self, print_str):
        self.make_log(print_str)

    @pyqtSlot(str)
    def make_log(self, print_str):
        self.now_time = datetime.datetime.now()
        self.now_date = self.now_time.strftime('[%Y-%m-%d %H:%M:%S]  ') + print_str
        self.finished.emit(self.now_date)   # signal MyWindow에 전달

    def GetTime(self):
        self.now_time = datetime.datetime.now()
        return self.now_time

# UI 구성 클래스
class MyWindow(QMainWindow, form_class):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.cnt = 0
        self.setWindowIcon(QIcon('./driver/naver-icon-style-1-300x300.png'))    # UI에 Naver icon 설정
        self.run_btn.clicked.connect(self.Run)  # 검색 버튼 누르면 self.Run 함수 실행
        self.process_delay = 1.5
        self.text = TextBrowser()               # UI에 text 출력 위한 객체
        self.text.finished.connect(self.ConnectTextBrowser) # TextBrowser한테서 signal 받으면 ConnectTextBrowser 함수 실행
        self.exit_btn.clicked.connect(self.QuitProgram) # 종료 버튼 클릭하면 프로그램 종료되게끔 설정 & thread 종료
        self.restart = False
        self.amt_review.clicked.connect(self.SetReviewType) # 리뷰 많은순
        self.good_review.clicked.connect(self.SetReviewType)# 리뷰 좋은순
        self.review_type = 0
        self.view_item_cnt = 80

    # UI 창닫기 버튼 클릭하면 종료 의사 묻는 팝업창 띄우기
    def closeEvent(self, QCloseEvent): 
        ans = QMessageBox.question(self, "종료 확인", "종료하시겠습니까?",
                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if ans == QMessageBox.Yes:
            QCloseEvent.accept()
            self.KillThread()
        else:
            QCloseEvent.ignore()
    
    # 종료 버튼 누르면 실행되는 함수
    def QuitProgram(self):
        QCoreApplication.instance().quit
        self.KillThread()

    # 검색 버튼 누르면 실행되는 Run 함수
    def Run(self):
        self.th = threading.Thread(target=self.StartCrawl)
        self.th.start()
    
    # 네이버 쇼핑 크롤링 함수
    def StartCrawl(self):
        self.text.run('--Start work--')
        self.start_time = self.text.GetTime()
        
        try:
            self.target_word = self.input_item_name.text()  # 입력한 아이템 이름 
        except:
            self.target_word == ''
            self.text.run('원하시는 아이템 이름을 입력해주세요!')
            return
        try:
            self.count = int(self.input_page_cnt.text())    # 입력한 검색 페이지 수
        except:
            self.count = 1

        if self.restart == False:
            self.OpenUrl()
        else:
            self.Restart()
        self.CrawlData()

    # 네이버쇼핑 URL 오픈
    @pyqtSlot()
    def OpenUrl(self):
        try:
            shutil.rmtree(r"c:\chrometemp")  #쿠키 / 캐쉬파일 삭제
        except FileNotFoundError:
            pass
        
        try:
            subprocess.Popen(r'C:\Program Files\Google\Chrome\Application\chrome.exe --remote-debugging-port=9222 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동
        except:
            subprocess.Popen(r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe --remote-debugging-port=9222 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동

        self.options = webdriver.ChromeOptions()
        self.options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
        # 크롬 버전을 확인하여 버전이 안맞으면 자동으로 업데이트 하여 설치해주는 옵션
        chrome_ver = chromedriver_autoinstaller.get_chrome_version().split('.')[0]
        try:
            self.driver = webdriver.Chrome(f'./{chrome_ver}/chromedriver.exe', options=self.options)
        except:
            chromedriver_autoinstaller.install(True)
            self.driver = webdriver.Chrome(f'./{chrome_ver}/chromedriver.exe', options=self.options)
        self.driver.implicitly_wait(10)

        # 속도 향상을 위한 옵션 해제
        self.options.add_argument("disable-gpu") 
        self.options.add_argument("disable-infobars")
        self.options.add_argument("--disable-extensions")
        prefs = {'profile.default_content_setting_values': {'cookies' : 2, 'images': 2, 'plugins' : 2, 'popups': 2, 'geolocation': 2, 'notifications' : 2, 'auto_select_certificate': 2, 'fullscreen' : 2, 'mouselock' : 2, 'mixed_script': 2, 'media_stream' : 2, 'media_stream_mic' : 2, 'media_stream_camera': 2, 'protocol_handlers' : 2, 'ppapi_broker' : 2, 'automatic_downloads': 2, 'midi_sysex' : 2, 'push_messaging' : 2, 'ssl_cert_decisions': 2, 'metro_switch_to_desktop' : 2, 'protected_media_identifier': 2, 'app_banner': 2, 'site_engagement' : 2, 'durable_storage' : 2}}   
        self.options.add_experimental_option('prefs', prefs)
        # 크롬 브라우저와 셀레니움을 사용하면서 발생되는 '시스템에 부착된 장치가 작동하지 않습니다.' 라는 크롬 브라우저의 버그를 조치하기 위한 코드. 
        self.options.add_experimental_option("excludeSwitches", ["enable-logging"])

        # 윈도우 사이즈 맥스로 키우기
        self.driver.maximize_window()
        self.driver.get('https://www.naver.com')
        self.text.run('네이버 URL open 완료')

        time.sleep(self.process_delay)

    # 네이버쇼핑 크롤링 함수
    def CrawlData(self):
        result_header = list(pd.read_excel('./driver/결과양식.xlsx'))
        ac = ActionChains(self.driver)  # 셀레니움 동작을 바인딩 하여 동작 할 수 있게 하는 모듈
        # 쇼핑 배너 클릭
        if self.restart == False:
            shopping_btn = self.driver.find_element_by_xpath('//*[@id="NM_FAVORITE"]/div[1]/ul[1]/li[5]/a').click()
        try:
            # 쇼핑 페이지로 잘 넘어왔는지 체크하는 코드
            element = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#_verticalGnbModule > div > div._header_header_REoTl > div > div._gnb_header_shop_Xd6Hq > div > div._gnbSearch_search_area_3LAyd > form > fieldset > div > input')))
        except:
            self.text.run('네이버 쇼핑 URL open에 실패했습니다.')
            self.driver.quit()

        time.sleep(self.process_delay)
        # 검색창
        try:
            search_tab = self.driver.find_element_by_css_selector('#_verticalGnbModule > div > div._header_header_REoTl > div > div._gnb_header_shop_Xd6Hq > div > div._gnbSearch_search_area_3LAyd > form > fieldset > div > input')
        except:                                                    
            self.text.run('검색에 실패했습니다.')
            self.restart = True
            return 0
        # 검색창에 입력받은 아이템 이름 입력 후 엔터
        ac.move_to_element(search_tab).click().pause(2).send_keys(self.target_word).pause(1).send_keys(Keys.ENTER).perform()
        try:
            wait = WebDriverWait(self.driver, 10)
            element = wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="__next"]/div/div[1]')))
        except:
            self.text.run('검색에 실패했습니다.')
            self.restart = True
            return 0
        
        self.text.run('{} 검색 성공!'.format(self.target_word))
        time.sleep(self.process_delay)

        # 해외직구 클릭
        try:
            self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div.style_inner__18zZX > div.style_content_wrap__1PzEo > div.style_content__2T20F > div.seller_filter_area > ul > li:nth-child(6) > a').click()
        except:
            self.text.run('해외직구 탭 클릭에 실패했습니다. 프로그램을 다시 시작해주세요.')
            self.restart = True
            return 0
        time.sleep(self.process_delay)

         # 80개씩 보기
        view_item_tab = self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div.style_inner__18zZX > div.style_content_wrap__1PzEo > div.style_content__2T20F > div.seller_filter_area > div.subFilter_sort_area__ZBnvs > div.subFilter_sort_choice__1SFXG > div.subFilter_select_box__1bM64').click()
        WebDriverWait(self.driver, 5).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#__next > div > div.style_container__1YjHN > div.style_inner__18zZX > div.style_content_wrap__1PzEo > div.style_content__2T20F > div.seller_filter_area > div.subFilter_sort_area__ZBnvs > div.subFilter_sort_choice__1SFXG > div.subFilter_select_box__1bM64.open > ul > li:nth-child(4)'))).click()
        time.sleep(2)
        # 금액 설정
        self.start_price_str = self.start_price.text()
        self.end_price_str = self.end_price.text()
        if self.start_price_str != '' and self.end_price_str != '':
            time.sleep(3)
            try:
                start_price_tab = self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div.style_inner__18zZX > div.filter_finder__1Gtei > div > div.filter_finder_col__3ttPW.filter_finder_price__2UlfJ > div.finder_price_inner > div > span:nth-child(2) > input[type=text]')
                end_price_tab = self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div.style_inner__18zZX > div.filter_finder__1Gtei > div > div.filter_finder_col__3ttPW.filter_finder_price__2UlfJ > div.finder_price_inner > div > span:nth-child(4) > input[type=text]')
                search_price_btn = self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div.style_inner__18zZX > div.filter_finder__1Gtei > div > div.filter_finder_col__3ttPW.filter_finder_price__2UlfJ > div.finder_price_inner > div > a')
            except:
                try:
                    start_price_tab = self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div > div.filter_finder__1Gtei > div > div.filter_finder_col__3ttPW.filter_finder_price__2UlfJ > div.finder_price_inner > div > span:nth-child(2) > input[type=text]')
                    end_price_tab = self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div > div.filter_finder__1Gtei > div > div.filter_finder_col__3ttPW.filter_finder_price__2UlfJ > div.finder_price_inner > div > span:nth-child(4) > input[type=text]')
                    search_price_btn = self.driver.find_element_by_css_selector('#__next > div > div.style_container__1YjHN > div > div.filter_finder__1Gtei > div > div.filter_finder_col__3ttPW.filter_finder_price__2UlfJ > div.finder_price_inner > div > a')
                except:
                    self.text.run('금액설정에 실패했습니다.')
                    self.restart = True
                    return 0
                
            # 금액 설정란에 입력받은 금액 입력 후 엔터
            ac.move_to_element(start_price_tab).click().pause(2).send_keys(self.start_price_str).pause(2).perform()
            ac.move_to_element(end_price_tab).click().pause(2).send_keys(self.end_price_str).pause(2).perform()
            ac.move_to_element(search_price_btn).click().perform()
            time.sleep(self.process_delay)

        # 리뷰 타입 받아서 정렬
        try:
            if self.review_type == 0:
                review_type_selector = '//*[@id="__next"]/div/div[2]/div[2]/div[3]/div[1]/div[2]/div[1]/div[1]/a[4]'
                review_type_str = '리뷰 많은순'
            elif self.review_type == 1:
                review_type_selector = '//*[@id="__next"]/div/div[2]/div[2]/div[3]/div[1]/div[2]/div[1]/div[1]/a[5]'
                review_type_str = '리뷰 좋은순'
            try:
                WebDriverWait(self.driver, 5).until(EC.presence_of_element_located((By.XPATH, review_type_selector))).click()
            except:
                if self.review_type == 0:
                    review_type_selector = '//*[@id="__next"]/div/div[2]/div/div[3]/div[1]/div[1]/div/div[1]/a[4]'
                    review_type_str = '리뷰 많은순'
                elif self.review_type == 1:
                    review_type_selector = '//*[@id="__next"]/div/div[2]/div/div[3]/div[1]/div[1]/div/div[1]/a[5]'
                    review_type_str = '리뷰 좋은순'
                WebDriverWait(self.driver, 5).until(EC.presence_of_element_located((By.XPATH, review_type_selector))).click()
        except:
            self.text.run('{} 클릭에 실패했습니다.'.format(review_type_str))
            self.restart = True
            return 0
        time.sleep(self.process_delay)
        
        # 페이지 끝까지 스크롤
        # # 윈도우의 첫 좌표 대비 끝 좌표를 비교하여 같을 때까지 스크롤바를 내리는 로직
        # before_h = self.driver.execute_script('return window.scrollY')
        # while(True):
        #     self.driver.find_element_by_css_selector('body').send_keys(Keys.END)
        #     time.sleep(1)
        #     after_h = self.driver.execute_script('return window.scrollY')

        #     if after_h == before_h:
        #         break
        #     else:
        #         before_h = after_h

        before_h = 0
        after_h =0
        # 엑셀 파일에 담을 리스트 초기화
        wb = openpyxl.Workbook()
        sheet = wb.active
        #sheet.append(['상품명', '최저가', '스토어 갯수', '별점', '리뷰 갯수', '등록월', '스토어 링크'])
#        sheet.append(['상품명', '최저가', '별점', '리뷰 갯수', '등록월', '스토어 링크'])    # 스토어 갯수가 없는 경우가 많아 크롤링 속도가 느려지는 경우가 많이 발생
        sheet.append(result_header)
        previousItemList = []
        now_time = datetime.datetime.now()
        today = now_time.strftime('%Y%m%d')  #YYYY-MM-DD
        rank_dict = {'M44001':'플래티넘', 'M44002':'프리미엄', 'M44003':'빅파워', 'M44004':'파워', 'M44005':'없음', 'M44006':'없음', 'M44007':'없음', 'M44008':'없음', 'M44009':'없음'}
        for i in range(self.count):
#            if i != 0:
#                self.driver.refresh()
#                time.sleep(5)
            # 페이지 끝까지 스크롤
            before_h = self.driver.execute_script('return window.scrollY')
            while(True):
                self.driver.find_element_by_css_selector('body').send_keys(Keys.END)
                time.sleep(1)
                after_h = self.driver.execute_script('return window.scrollY') 

                if after_h == before_h:
                    break
                else:
                    before_h = after_h

            idx = 0
            no_review = False
            # 각 아이템별 데이터 크롤링
            url = self.driver.current_url
            headers = {
                'authority': 'search.shopping.naver.com',
                'accept': 'application/json, text/plain, */*',
                'accept-language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
                'cache-control': 'no-cache',
                # Requests sorts cookies= alphabetically
                #'cookie': 'NNB=KE7HSLOVP2HWE; sus_val=wwt7vHRgRRrfnhDlgIWFQ840; autocomplete=use; AD_SHP_BID=6; spage_uid=',
                'logic': 'PART',
                'pragma': 'no-cache',
                'Referer': url,
                'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="102", "Google Chrome";v="102"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"Windows"',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-origin',
                'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.61 Safari/537.36',
            }
            windows_user_name = os.path.expanduser('~')

            self.store_name = []
            self.store_rank = []
            self.purchase_cnt = []
            self.store_link = []
            self.image_name = []
            self.image_save_link = []
            self.category = []
            self.item_name = []
            self.tag = []
            self.review_cnt = []
            self.price = []
            self.delivery_fee = []
            
            time.sleep(1.5)
            # 네이버를 향한 Request 생성 and 네이버로부터 response 받기
            response = self.MakeRequestAndGetResponse(i+1, headers)
            
            # json을 리스트로 받기
            itemList = json.loads(response.text)
            idx = 0
            for item in itemList['shoppingResult']['products']:
                review_cnt = item['reviewCountSum']
                if review_cnt == 0:
                    self.text.run('{}페이지 {}번째 아이템 리뷰 없음'.format(i + 1, idx + 1))
                    no_review = True
                    break
                else:
                    self.review_cnt.append(review_cnt)
                shop_list = item['lowMallList']
                if shop_list != None:
                    store_name = []
                    for d in range(len(shop_list)):
                        temp = item['lowMallList'][d]['name']
                        new_temp = self.CleanText(temp).replace(' ', '')
                        store_name.append(new_temp)
                    self.store_name.append(', '.join(store_name))
                else:
                    temp = item['mallName']
                    new_temp = self.CleanText(temp).replace(' ', '')
                    self.store_name.append(new_temp)
                try:
                    self.store_rank.append(rank_dict[item['mallInfoCache']['mallGrade']])
                except:
                    self.store_rank.append('없음')
                self.purchase_cnt.append(item['purchaseCnt'])
                self.store_link.append(item['mallProductUrl'])
                
                item_name = item['productName']
                new_item_name = self.CleanText(item_name)
                self.image_name.append(new_item_name.replace(' ','_'))

                category_level = int(item['categoryLevel'])
                category_temp = []
                for n in range(category_level):
                    category_temp.append(item['category{}Name'.format(n+1)])
                self.category.append('>'.join(category_temp))

                self.item_name.append(new_item_name)
                self.tag.append(item['manuTag'])
                self.price.append(item['lowPrice'])
                self.delivery_fee.append(item['deliveryFeeContent'])

                # 이미지 파일 저장
                img_url = item['imageUrl']
                img_folder = '{}\\Desktop\\{}_네이버'.format(windows_user_name, today)
                if ', ' in self.store_name[idx]:
                    sub_img_folder = '{}\\Desktop\\{}_네이버\\{}'.format(windows_user_name, today, self.store_name[idx].split(', ')[0])
                else:
                    sub_img_folder = '{}\\Desktop\\{}_네이버\\{}'.format(windows_user_name, today, self.store_name[idx])
                self.image_save_link.append(sub_img_folder + '\\' + self.image_name[idx] + '.jpg')

                try:
                    if not os.path.isdir(img_folder):
                        os.mkdir(img_folder)
                    if not os.path.isdir(sub_img_folder):
                        os.mkdir(sub_img_folder)
                except OSError:
                    self.text.run('이미지 폴더를 생성하는데 실패했습니다.')
                    break
                t = urllib.request.urlretrieve(img_url, self.image_save_link[idx])

                # 크롤링 결과 엑셀로 저장
                current_path = os.getcwd()
                now_time = datetime.datetime.now()
                now_date = now_time.strftime('%Y-%m-%d') + '_'  #YYYY-MM-DD
                sheet.append([self.store_name[idx], self.store_rank[idx], self.purchase_cnt[idx], self.store_link[idx], self.image_name[idx], 
                              self.image_save_link[idx], self.category[idx], self.item_name[idx], self.tag[idx], self.review_cnt[idx], 
                              self.price[idx], self.delivery_fee[idx]])
                wb.save("{}\\".format(current_path) + now_date + self.target_word.replace('/','') + "_results.xlsx")
                #wb.save("{}\\".format(img_folder) + now_date + self.target_word.replace('/','') + "_results.xlsx")

                result_folder = self.result_folder.text()
                if result_folder == '':
                    result_folder = "네이버 결과물"

                result_path = windows_user_name + '\\Desktop\\' + result_folder + '\\'
                try:
                    if not os.path.isdir(result_path):
                        os.mkdir(result_path)
                except OSError:
                    self.text.run('결과물 폴더를 생성하는데 실패했습니다.')
                    break

                wb.save('{}'.format(result_path) + self.target_word.replace('/','') + "_results.xlsx")

                self.text.run('{}페이지 {}번째 아이템 크롤링 중'.format(i + 1, idx + 1))

                idx += 1
            
            time.sleep(self.process_delay)
            self.text.run('{}페이지 크롤링 완료!'.format(i + 1))
            if no_review == True:
                break
            if i != self.count - 1:
                # 다음 페이지로 넘기기
                self.driver.find_element_by_css_selector('.pagination_next__1ITTf').click()
                time.sleep(self.process_delay)

            # 반복 응답 Check Method
            # 응답이 같은 값으로 반복되었는지 확인하는 메서드를 실행한다. True일 경우 중복이라서 break
            if i == 0:
                previousItemList = itemList
                continue

            if self.isRepeat(previousItemList, itemList):
                break
            
            previousItemList = itemList
                
        # 크롬드라이버 종료
        self.end_time = self.text.GetTime()
        diff_time = self.end_time - self.start_time
        self.text.run('--End work--')
        self.text.run('총 소요시간은 {}초 입니다.'.format(diff_time.seconds))
        self.restart = True
        return 1
    
    def isRepeat(self, previousItemList, itemList) :
    
        #같은 값을 응답받으면 True 리턴
        if previousItemList['shoppingResult']['products'][0]['productName'] == itemList['shoppingResult']['products'][0]['productName']:
            self.text.run('중복된 페이지 크롤링을 시도했습니다. 크롤링을 종료합니다.')
            return True
        #아니면 False 리턴
        return False

    def MakeRequestAndGetResponse(self, number, headers) :
        pageingIndex = number

        params = {
            'sort':'review',
            'pagingIndex': pageingIndex,
            'pagingSize': 80,
            'viewType': 'list',
            'productSet': 'overseas',
            'deliveryFee': '',
            'deliveryTypeValue': '',
            'frm': 'NVSHPRC',
            'query': self.target_word,
            'iq': '',
            'eq': '',
            'xq': '',
            'minPrice': self.start_price_str,
            'maxPrice': self.end_price_str,
        }

        response = requests.get('https://search.shopping.naver.com/api/search/all', headers=headers, params=params)

        return response

    def CleanText(self, inputString):
        text_rmv = re.sub('[-=+,#/\?:^.@*\"※~ㆍ!』‘|\(\)\[\]`\'…》\”\“\’·]', ' ', inputString)
        return text_rmv

    # 리뷰 타입 선택
    def SetReviewType(self):
        if self.amt_review.isChecked():
            self.review_type = 0
        elif self.good_review.isChecked():
            self.review_type = 1

    # 크롤링 재시작
    def Restart(self):
        self.driver.get('https://shopping.naver.com/home/p/index.naver')
        self.text.run('네이버 쇼핑 URL re-open 완료')
        time.sleep(self.process_delay)

    # 쓰레드 종료
    def KillThread(self):
        pid = os.getpid()
        os.kill(pid, 2)

    # UI에 텍스트 출력
    @pyqtSlot(str)
    def ConnectTextBrowser(self, print_str):
        self.textBrowser.append(print_str)
        self.textBrowser.repaint()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()
