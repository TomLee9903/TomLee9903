# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import uic
from PyQt5.QtCore import *
from PyQt5.QtCore import pyqtSlot

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver import ActionChains
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import sys
import time
import datetime
import os
import pandas as pd
import threading
import subprocess
from enum import Enum
import openpyxl
import pyautogui
import tkinter
from tkinter.filedialog import askopenfilename
import googletrans as google
import requests
import urllib
import json

class SearchType(Enum):
    SINGLE = 1
    MULTIPLE = 2

class Result(Enum):
    FAIL = 0
    PASS = 1
    FINISH = 2

class NameType(Enum):
    BRAND_NAME = 0
    ITEM_NAME = 1

class Available(Enum):
    DISABLE = 0
    ENABLE = 1

# QT designer ui 파일 로드
form_class = uic.loadUiType("./driver/main_ui.ui")[0]

# UI 텍스트 출력 클래스
class TextBrowser(QThread):
    # signal을 MyWindow에 전달할 수 있게 하는 인자
    finished = pyqtSignal(str)
    now_date = ''

    @pyqtSlot(str)
    def run(self, print_str):
        self.make_log(print_str)

    @pyqtSlot(str)
    def make_log(self, print_str):
        self.now_time = datetime.datetime.now()
        self.now_date = self.now_time.strftime('[%Y-%m-%d %H:%M:%S]  ') + print_str
        self.finished.emit(self.now_date)   # signal MyWindow에 전달

    def GetTime(self):
        self.now_time = datetime.datetime.now()
        return self.now_time

# UI 구성 클래스
class MyWindow(QMainWindow, form_class):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.setWindowIcon(QIcon('./driver/MainImage.png'))    # UI에 구글 번역 icon 설정
        self.run_btn.clicked.connect(self.Run)  # 검색 버튼 누르면 self.Run 함수 실행
        self.process_delay = 1.5
        self.text = TextBrowser()               # UI에 text 출력 위한 객체
        self.windows_user_name = os.path.expanduser('~')
        self.search_type = SearchType.SINGLE
        self.filename = ''
        self.enable_network_search = False
        self.allow_ratio = 0.0
        self.ratio = pd.DataFrame()
        self.translator = google.Translator()
        self.url_link = ''
        self.pgm_ver = 'v24012002'
        self.category = pd.DataFrame()

        self.text.finished.connect(self.ConnectTextBrowser) # TextBrowser한테서 signal 받으면 ConnectTextBrowser 함수 실행
        self.exit_btn.clicked.connect(self.QuitProgram) # 종료 버튼 클릭하면 프로그램 종료되게끔 설정 & thread 종료
        self.enable_multiple_search_btn.clicked.connect(self.SetMultipleSearch)
        
        # Set admin state
        self.admin_all_btn.clicked.connect(self.SetAdminStateAll)

        # Set File path to analyze brand name
        self.set_file_path_btn.clicked.connect(self.SetFilePath)

        # Analyze brand name
        self.start_analyze_btn.clicked.connect(self.RunAnalyzeBrandName)
        self.start_naver_analyze_btn.clicked.connect(self.RunAnalyzeNaverCategory)
        self.enable_network_search_btn.clicked.connect(self.SetNetworkSearch)

    # UI 창닫기 버튼 클릭하면 종료 의사 묻는 팝업창 띄우기
    def closeEvent(self, QCloseEvent): 
        ans = QMessageBox.question(self, "종료 확인", "종료하시겠습니까?",
                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if ans == QMessageBox.Yes:
            QCloseEvent.accept()
            self.KillThread()
        else:
            QCloseEvent.ignore()
    
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()
 
    def dropEvent(self, event):
        files = [u.toLocalFile() for u in event.mimeData().urls()]
        self.filename = files[0]
        self.df = pd.read_excel(self.filename)
        self.df.fillna('', inplace=True)
        self.text.run('파일 이름 : {}'.format(self.filename.split('/')[-1].replace('.xlsx','')))
        self.file_path_input.setText(self.filename)

    # 종료 버튼 누르면 실행되는 함수
    def QuitProgram(self):
        QCoreApplication.instance().quit
        self.KillThread()

    def SetMultipleSearch(self):
        if self.enable_multiple_search_btn.isChecked():
            self.search_type = SearchType.MULTIPLE
        else:
            self.search_type = SearchType.SINGLE
    
    # 검색 버튼 누르면 실행되는 Run 함수
    def Run(self):
        self.th = threading.Thread(target=self.Start)
        self.th.start()

    # 상품명 분석 누르면 실행되는 Run 함수
    def RunAnalyzeBrandName(self):
        self.th2 = threading.Thread(target=self.AnalyzeBrandName)
        self.th2.start()

    def RunAnalyzeNaverCategory(self):
        self.th3 = threading.Thread(target=self.AnalyzeNaverCategory)
        self.th3.start()

    # 파파고 URL 오픈
    @pyqtSlot()
    def OpenUrl(self, url_link=''):
        if 'naver' in url_link:
            url_name = '네이버'
        else:
            url_name = '키프리스'
        try:
            subprocess.Popen(r'C:\Program Files\Google\Chrome\Application\chrome.exe --remote-debugging-port=9225 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동
        except:
            subprocess.Popen(r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe --remote-debugging-port=9225 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동
        
        self.options = webdriver.ChromeOptions()
        user_agent = "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.83 Safari/537.36"
        self.options.add_argument('user-agent=' + user_agent)
        self.options.add_experimental_option("debuggerAddress", "127.0.0.1:9225")

        # 크롬 버전을 확인하여 버전이 안맞으면 자동으로 업데이트 하여 설치해주는 옵션       
        self.driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=self.options)
        self.driver.implicitly_wait(10)
        
        # 속도 향상을 위한 옵션 해제
        self.options.add_argument("disable-gpu") 
        self.options.add_argument("disable-infobars")
        self.options.add_argument("--disable-extensions")
        prefs = {'profile.default_content_setting_values': {'cookies' : 2, 'images': 2, 'plugins' : 2, 'popups': 2, 'geolocation': 2, 'notifications' : 2, 'auto_select_certificate': 2, 'fullscreen' : 2, 'mouselock' : 2, 'mixed_script': 2, 'media_stream' : 2, 'media_stream_mic' : 2, 'media_stream_camera': 2, 'protocol_handlers' : 2, 'ppapi_broker' : 2, 'automatic_downloads': 2, 'midi_sysex' : 2, 'push_messaging' : 2, 'ssl_cert_decisions': 2, 'metro_switch_to_desktop' : 2, 'protected_media_identifier': 2, 'app_banner': 2, 'site_engagement' : 2, 'durable_storage' : 2}}   
        #self.options.add_experimental_option('prefs', prefs)
        # 크롬 브라우저와 셀레니움을 사용하면서 발생되는 '시스템에 부착된 장치가 작동하지 않습니다.' 라는 크롬 브라우저의 버그를 조치하기 위한 코드. 
        self.options.add_experimental_option("excludeSwitches", ["enable-logging"])

        # 윈도우 사이즈 맥스로 키우기
        self.driver.maximize_window()
        self.driver.get(url_link)
        time.sleep(1)
        pyautogui.press('f12')
        time.sleep(2)
        pyautogui.press('f12')

        self.text.run('{} URL open 완료'.format(url_name))
        self.ac = ActionChains(self.driver)  # 셀레니움 동작을 바인딩 하여 동작 할 수 있게 하는 모듈                    

        time.sleep(self.process_delay)
    
    def Retry(self):
        # URL open
        self.driver.close()
        time.sleep(2)
        self.OpenUrl(self.url_link)
        time.sleep(2)

        ret = self.PressSmartSearch()
        if ret == Result.FAIL:
            self.text.run('스마트검색 클릭에 실패했습니다.')
            return
        time.sleep(1)
        
        self.driver.find_element(By.CSS_SELECTOR, '#measure01').click()
        time.sleep(1)
        for i in range(len(self.admin_state)):
            check_state = eval('self.admin_{}_btn'.format(i+1)).checkState()
            if check_state == 2:
                self.admin_state[i] = Available.ENABLE
            else:
                self.admin_state[i] = Available.DISABLE
            
            if self.admin_state[i] == Available.ENABLE:
                elem_name = '#measure0{}'.format(i+2)
                self.driver.find_element(By.CSS_SELECTOR, elem_name).click()
                time.sleep(0.3)

        ret = self.PressFullySameButton()
        if ret == Result.FAIL:
            self.text.run('완전일치검색 클릭에 실패했습니다.')
            return
        time.sleep(1)
        ret = self.PressSmartSearch()
    
    def ReOpenUrl(self):
        # URL open
        self.driver.close()
        time.sleep(2)
        self.OpenUrl(self.url_link)
        time.sleep(2)

    @pyqtSlot()
    # 징동닷컴 크롤링 함수
    def Start(self):
        self.url_link = 'http://kdtj.kipris.or.kr/kdtj/searchLogina.do?method=loginTM'
        self.text.run('--Start work--')
        self.text.run('PGM ver : {}'.format(self.pgm_ver))
        self.start_time = self.text.GetTime()
        self.i = 0
        self.j = 0
        ret = Result.PASS
        # URL open
        self.OpenUrl(self.url_link)
        time.sleep(2)
        
        # Gather search list depending on search type
        if self.enable_network_search == True:
            self.search_type = SearchType.MULTIPLE
            self.search_list = pd.DataFrame()
            if self.allow_min_ratio_input.text() != '':
                self.allow_min_ratio = float(self.allow_min_ratio_input.text())
            else:
                self.allow_min_ratio = 0.0

            if self.allow_max_ratio_input.text() != '':
                self.allow_max_ratio = float(self.allow_max_ratio_input.text())
            else:
                self.allow_max_ratio = 100.0

            if len(self.ratio) < 1:
                filename = self.GetFileName()
                self.ratio = pd.read_excel(filename)
                self.ratio.fillna('', inplace=True)

            for i in range(len(self.ratio)):
                ratio = self.ratio.loc[i, '포함비율']
                if ratio >= self.allow_min_ratio and ratio < self.allow_max_ratio:
                    self.search_list.loc[i, str('상표명칭')] = self.ratio.loc[i, '키워드명']
                    self.search_list.loc[i, str('지정상품')] = self.ratio.loc[i, '지정상품명']
        else:
            if self.search_type == SearchType.MULTIPLE:
                self.search_list = pd.read_excel('./driver/SearchList.xlsx')
            else:
                self.search_list = pd.DataFrame()
                if self.brand_name_input.text() != '':
                    self.search_list.loc[0, str('상표명칭')] = self.brand_name_input.text()
                else:
                    self.text.run('상표명칭을 입력해주세요.')
                    return
                if self.item_name_input.text() != '':
                    self.search_list.loc[0, str('지정상품')] = self.item_name_input.text()
                else:
                    self.text.run('지정상품을 입력해주세요.')
                    return
        
        # Initialize admin state buttons
        self.admin_state = [0, 0, 0, 0, 0, 0, 0, 0]
        columns = ['상표명칭', '지정상품', '상표권유무']
        self.wb = openpyxl.Workbook()
        self.sheet = self.wb.active
        self.sheet.append(columns)

        cnt = 0
        i = 0
        #for i in range(len(self.search_list)):
        while i < len(self.search_list):
            brand_name = self.search_list.iloc[i][NameType.BRAND_NAME.value]
            item_name = self.search_list.iloc[i][NameType.ITEM_NAME.value].split('/')[0]
            if item_name == '':
                self.text.run('{}번째 지정상품명이 공백입니다. 다음으로 넘어갑니다.'.format(i + 1))
                i += 1
                continue
            
            if i != 0:
                time.sleep(1)
                self.driver.execute_script("window.scrollTo(0, 100)")
                time.sleep(1)

            ret = self.PressSmartSearch()
            if ret == Result.FAIL:
                self.text.run('스마트검색 클릭에 실패했습니다.')
                self.Retry()
                continue
            time.sleep(1)

            # Set admin state
            if i == 0:
                self.driver.find_element(By.CSS_SELECTOR, '#measure01').click()
                time.sleep(1)
                for j in range(len(self.admin_state)):
                    check_state = eval('self.admin_{}_btn'.format(j+1)).checkState()
                    if check_state == 2:
                        self.admin_state[j] = Available.ENABLE
                    else:
                        self.admin_state[j] = Available.DISABLE
                    
                    if self.admin_state[j] == Available.ENABLE:
                        elem_name = '#measure0{}'.format(j+2)
                        self.driver.find_element(By.CSS_SELECTOR, elem_name).click()
                        time.sleep(0.3)

                ret = self.PressFullySameButton()
                if ret == Result.FAIL:
                    self.text.run('완전일치검색 클릭에 실패했습니다.')
                    self.Retry()
                    continue
                time.sleep(1)

            ret = self.PunInBrandName(brand_name)
            if ret == Result.FAIL:
                self.text.run('상표명칭 입력에 실패했습니다.')
                self.Retry()
                continue
            time.sleep(1)

            ret = self.PunInItemName(item_name)
            if ret == Result.FAIL:
                self.text.run('지정상품 입력에 실패했습니다.')
                self.Retry()
                continue
            time.sleep(1)

            ret = self.PressSearchButton()
            if ret == Result.FAIL:
                self.text.run('상품 검색에 실패했습니다.')
                self.Retry()
                continue
            time.sleep(5)

            # 상표권 유무
            try:
                no_found = self.driver.find_element(By.CSS_SELECTOR, '#content').text
                if '없습니다' in no_found:
                    is_exist = '없음'
                else:
                    is_exist = '있음'
            except:
                is_exist = '있음'
                
            self.sheet.append([brand_name, item_name, is_exist])
            if self.search_type == SearchType.MULTIPLE:
                self.SaveFile('다중검색')
            else:
                self.SaveFile('{}_{}'.format(brand_name, item_name))

            self.text.run('[{} / {}] 검색을 완료했습니다. 결과 : 상표권 {}'.format(brand_name, item_name, is_exist))
            self.text.run('{}개 / {}개 검색 중'.format(i+1, len(self.search_list)))
            i += 1

        self.end_time = self.text.GetTime()
        diff_time = self.end_time - self.start_time
        self.text.run('--End work--')
        self.text.run('총 소요시간은 {}초 입니다.'.format(diff_time.seconds))
        self.driver.close()

    @pyqtSlot()
    def AnalyzeNaverCategory(self):
        ret = Result.PASS
        self.url_link = 'https://shopping.naver.com/home'
        self.category_ref = pd.read_excel('./driver/category_reference.xlsx').fillna('없음')
        self.start_time = self.text.GetTime()
        
        # URL open
        self.OpenUrl(self.url_link)
        time.sleep(2)

        item_list = list(self.df.iloc[:, 15])
        start_time = self.text.GetTime()
        i = 0
        cnt = 0
        while cnt < 50:
            if i == len(item_list):
                break
            # 상품명 검색
            try:
                self.driver.get('https://search.shopping.naver.com/search/all?query={}&pagingSize=80'.format(item_list[i]))
                time.sleep(1)
                age_check = self.driver.find_element(By.CSS_SELECTOR, '#container > div').text
                if '연령 확인' in age_check:
                    self.text.run('연령 확인이 필요한 상품명입니다. 다음으로 넘어갑니다.')
                    self.text.run('상품명 : {}'.format(item_list[i]))
                    self.category.loc[i, '상품제목'] = str(item_list[i])
                    self.category.loc[i, '카테고리대분류'] = '없음'
                    self.category.loc[i, '카테고리중분류'] = '없음'
                    self.category.loc[i, '카테고리소분류'] = '없음'
                    self.category.loc[i, '카테고리세분류'] = '없음'
                    self.category.loc[i, '카테고리코드'] = '없음'
                    
                    ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')
                    if ret == Result.FAIL:
                        ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')

                    self.text.run('{} : {} > {} > {} > {}'.format(item_list[i], self.category.loc[i, '카테고리대분류'], self.category.loc[i, '카테고리중분류'], 
                                                                self.category.loc[i, '카테고리소분류'], self.category.loc[i, '카테고리세분류']))
                    self.text.run('{} / {}개 분석 완료'.format(i + 1, len(item_list)))
                    i += 1
                    continue
            except:                                                    
                self.text.run('검색에 실패했습니다.')
                self.ReOpenUrl()
                cnt += 1
                continue
            
            try:
                no_result = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#container > div'))).text
                if '없습니다.' in no_result:
                    self.category.loc[i, '상품제목'] = str(item_list[i])
                    self.category.loc[i, '카테고리대분류'] = '없음'
                    self.category.loc[i, '카테고리중분류'] = '없음'
                    self.category.loc[i, '카테고리소분류'] = '없음'
                    self.category.loc[i, '카테고리세분류'] = '없음'
                    self.category.loc[i, '카테고리코드'] = '없음'
                    
                    ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')
                    if ret == Result.FAIL:
                        ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')

                    self.text.run('{} : {} > {} > {} > {}'.format(item_list[i], self.category.loc[i, '카테고리대분류'], self.category.loc[i, '카테고리중분류'], 
                                                                self.category.loc[i, '카테고리소분류'], self.category.loc[i, '카테고리세분류']))
                    self.text.run('{} / {}개 분석 완료'.format(i + 1, len(item_list)))
                    i += 1
                    continue
            except:
                no_result = self.driver.find_element(By.CSS_SELECTOR, '#container > div > div.noResultWithBestResults_no_result__FOoXE > div.noResultWithBestResults_no_keyword___Jhtn').text
                if '없습니다.' in no_result:
                    self.category.loc[i, '상품제목'] = str(item_list[i])
                    self.category.loc[i, '카테고리대분류'] = '없음'
                    self.category.loc[i, '카테고리중분류'] = '없음'
                    self.category.loc[i, '카테고리소분류'] = '없음'
                    self.category.loc[i, '카테고리세분류'] = '없음'
                    self.category.loc[i, '카테고리코드'] = '없음'
                    
                    ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')
                    if ret == Result.FAIL:
                        ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')

                    self.text.run('{} : {} > {} > {} > {}'.format(item_list[i], self.category.loc[i, '카테고리대분류'], self.category.loc[i, '카테고리중분류'], 
                                                                self.category.loc[i, '카테고리소분류'], self.category.loc[i, '카테고리세분류']))
                    self.text.run('{} / {}개 분석 완료'.format(i + 1, len(item_list)))
                    i += 1
                    continue
                else:
                    self.text.run('검색에 실패했습니다.')
                    self.ReOpenUrl()
                    cnt += 1
                    continue
            
            time.sleep(self.process_delay)

            # 스크롤바 내리기
            ret = self.ScrollPageDown()
            if ret == Result.FAIL:
                self.text.run('웹페이지 로딩에 실패했습니다.')
                self.ReOpenUrl()
                cnt += 1
                continue
            
            try:
                # 카테고리 정보 수집
                ii = 0
                searched_list = self.driver.find_element(By.CSS_SELECTOR, '#container > div').get_attribute('innerHTML').split('product_item__MDtDF')[1:]
                category_list = self.category_ref.iloc[:, 1:5].fillna('없음')
                res_temp = pd.DataFrame()
                for item in searched_list:
                    splited_name = item.split('product_category__l4FWz product_nohover__Z0Muw')[1:]
                    for k in range(len(splited_name)):
                        splited_name[k] = splited_name[k].split('</span')[0].split('>')[1]
                    try:
                        idx = len(splited_name) - 1
                        matched_name = category_list[category_list.iloc[:, idx] == splited_name[idx]]
                        matched_idx = matched_name.index
                    except:
                        continue
                    
                    if matched_idx.empty != True:
                        res_temp.loc[ii, '상품제목'] = str(item_list[i])
                        res_temp.loc[ii, '카테고리대분류'] = str(self.category_ref.iloc[matched_idx, 1].values[0])
                        res_temp.loc[ii, '카테고리중분류'] = str(self.category_ref.iloc[matched_idx, 2].values[0])
                        res_temp.loc[ii, '카테고리소분류'] = str(self.category_ref.iloc[matched_idx, 3].values[0])
                        res_temp.loc[ii, '카테고리세분류'] = str(self.category_ref.iloc[matched_idx, 4].values[0])
                        res_temp.loc[ii, '카테고리코드'] = int(self.category_ref.iloc[matched_idx, 0].values[0])
                        ii += 1

                max_res_perc = int(res_temp['카테고리코드'].value_counts(normalize=True, sort=True).idxmax())
                df_idx = self.category_ref[self.category_ref.iloc[:, 0] == max_res_perc].index
                self.category.loc[i, '상품제목'] = str(item_list[i])
                self.category.loc[i, '카테고리대분류'] = str(self.category_ref.iloc[df_idx, 1].values[0])
                self.category.loc[i, '카테고리중분류'] = str(self.category_ref.iloc[df_idx, 2].values[0])
                self.category.loc[i, '카테고리소분류'] = str(self.category_ref.iloc[df_idx, 3].values[0])
                self.category.loc[i, '카테고리세분류'] = str(self.category_ref.iloc[df_idx, 4].values[0])
                self.category.loc[i, '카테고리코드'] = str(self.category_ref.iloc[df_idx, 0].values[0])
                
                ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')
                if ret == Result.FAIL:
                    ret = self.SaveFileWithDataFrame(self.category, self.filename.split('/')[-1].split('.')[0], '네이버카테고리분석')

                self.text.run('{} : {} > {} > {} > {}'.format(item_list[i], self.category.loc[i, '카테고리대분류'], self.category.loc[i, '카테고리중분류'], 
                                                            self.category.loc[i, '카테고리소분류'], self.category.loc[i, '카테고리세분류']))
                self.text.run('{} / {}개 분석 완료'.format(i + 1, len(item_list)))
                i += 1
            except:
                self.text.run('카테고리 정보 수집 도중 에러가 발생됐습니다. 재시도합니다 {}'.format(cnt + 1))
                self.ReOpenUrl()
                cnt += 1
                continue

        # 크롤링 종료
        end_time = self.text.GetTime()
        diff_time = end_time - start_time
        self.text.run('--End work--')
        self.text.run('총 소요시간은 {}초 입니다.'.format(diff_time.seconds))
        self.driver.close()

    def LogIn(self):
        ac = ActionChains(self.driver)
        # Get ID/PW
        self.id = self.id_input.text()
        self.pw = self.pw_input.text()

        #self.driver.find_element(By.CSS_SELECTOR, '#container > div > div > div.box__content > div > button.button__tab.button__tab--auction').click()
        self.driver.find_element(By.CSS_SELECTOR, '#container > div > div > div.box__content > div > button.button__tab.button__tab--gmarket').click()
        time.sleep(1)

        # log-in
        self.id_box = self.driver.find_element(By.CSS_SELECTOR, "#typeMemberInputId01")
        self.pw_box = self.driver.find_element(By.CSS_SELECTOR, "#typeMemberInputPassword01")
        self.login_button = self.driver.find_element(By.CSS_SELECTOR, '#container > div > div > div.box__content > form > div.box__submit > button')
        ac.send_keys_to_element(self.id_box, self.id).send_keys_to_element(self.pw_box, self.pw).click(self.login_button).pause(2).perform()
        time.sleep(5)
        
        # 팝업창 닫기
        if len(self.driver.window_handles) != 1:
            for n in range(len(self.driver.window_handles) - 1):
                last_tab = self.driver.window_handles[-1]
                self.driver.switch_to.window(window_name=last_tab)
                self.driver.close()
                time.sleep(1)
            first_tab = self.driver.window_handles[0]
            self.driver.switch_to.window(window_name=first_tab)
            time.sleep(self.process_delay)

    def PressSmartSearch(self):
        ret = Result.PASS
        try:
            self.driver.find_element(By.CSS_SELECTOR, '#ToggleSmartFinder').click()
        except:
            ret = Result.FAIL
        
        return ret

    def PunInBrandName(self, brand_name):
        ret = Result.PASS
        try:
            input_elem = self.driver.find_element(By.CSS_SELECTOR, '#TN')
            input_elem.clear()
            time.sleep(0.1)
            self.ac.send_keys_to_element(input_elem, brand_name).pause(0.5).perform()
        except:
            ret = Result.FAIL

        return ret

    def PunInItemName(self, item_name):
        ret = Result.PASS
        try:
            input_elem = self.driver.find_element(By.CSS_SELECTOR, '#GD')
            input_elem.clear()
            time.sleep(0.1)
            self.ac.send_keys_to_element(input_elem, item_name).pause(0.5).perform()
        except:
            ret = Result.FAIL
        
        return ret

    def PressFullySameButton(self):
        ret = Result.PASS
        try:
            self.driver.find_element(By.CSS_SELECTOR, '#searchInComplatesCk').click()
        except:
            ret = Result.FAIL
        
        return ret

    def PressSearchButton(self):
        ret = Result.PASS
        try:
            self.ac.send_keys(Keys.ENTER).perform()
        except:
            ret = Result.FAIL

        return ret

    def SetAdminStateAll(self):
        if self.admin_all_btn.isChecked():
            if self.admin_1_btn.isChecked() == False:
                self.admin_1_btn.toggle()
            if self.admin_2_btn.isChecked() == False:
                self.admin_2_btn.toggle()
            if self.admin_3_btn.isChecked() == False:
                self.admin_3_btn.toggle()
            if self.admin_4_btn.isChecked() == False:
                self.admin_4_btn.toggle()
            if self.admin_5_btn.isChecked() == False:
                self.admin_5_btn.toggle()
            if self.admin_6_btn.isChecked() == False:
                self.admin_6_btn.toggle()
            if self.admin_7_btn.isChecked() == False:
                self.admin_7_btn.toggle()
            if self.admin_8_btn.isChecked() == False:
                self.admin_8_btn.toggle()
        else:
            if self.admin_1_btn.isChecked() == True:
                self.admin_1_btn.toggle()
            if self.admin_2_btn.isChecked() == True:
                self.admin_2_btn.toggle()
            if self.admin_3_btn.isChecked() == True:
                self.admin_3_btn.toggle()
            if self.admin_4_btn.isChecked() == True:
                self.admin_4_btn.toggle()
            if self.admin_5_btn.isChecked() == True:
                self.admin_5_btn.toggle()
            if self.admin_6_btn.isChecked() == True:
                self.admin_6_btn.toggle()
            if self.admin_7_btn.isChecked() == True:
                self.admin_7_btn.toggle()
            if self.admin_8_btn.isChecked() == True:
                self.admin_8_btn.toggle()

    def SaveFile(self, suffix = ''):
        ret = Result.PASS
        now_time = self.text.GetTime().strftime('%y%m%d')

        file_folder = '{}\\Desktop\\키프리스_결과물'.format(self.windows_user_name)
        filename = '{}\\{}'.format(file_folder, '{}_{}_Kipris_SearchResults.xlsx'.format(now_time, suffix))
        try:
            if not os.path.isdir(file_folder):
                os.mkdir(file_folder)
        except OSError:
            self.text.run('파일 폴더를 생성하는데 실패했습니다.')
            return Result.FAIL

        self.wb.save(filename)
        return ret
    
    def SaveFileWithDataFrame(self, df, file_name, key_name='상품명분석'):
        ret = Result.PASS
        now_time = self.text.GetTime().strftime('%y%m%d')

        file_folder = '{}\\Desktop\\키프리스_결과물\\상품명_분석'.format(self.windows_user_name)
        filename = '{}\\{}'.format(file_folder, '{}_{}_{}_Kipris_SearchResults.xlsx'.format(now_time, file_name, key_name))
        try:
            if not os.path.isdir(file_folder):
                os.mkdir(file_folder)
        except OSError:
            self.text.run('파일 폴더를 생성하는데 실패했습니다.')
            return Result.FAIL

        df.to_excel(filename, index=False)
        return ret
    
    def SetFilePath(self):
        root = tkinter.Tk()
        root.withdraw()
        self.filename = askopenfilename(parent=root, filetypes=[('수집데이터 엑셀', '.xlsx')], initialdir=self.windows_user_name, title='분석을 원하시는 파일을 선택해주세요')
        if self.filename != '':
            self.df = pd.read_excel(self.filename)
            self.df.fillna('', inplace=True)
            self.text.run('파일 이름 : {}'.format(self.filename.split('/')[-1]))
        self.file_path_input.setText(self.filename)
    
    def GetFileName(self):
        root = tkinter.Tk()
        root.withdraw()
        filename = askopenfilename(parent=root, filetypes=[('분석데이터 엑셀', '상품명분석_Kipris_SearchResults.xlsx')], initialdir='{}/키프리스_결과물/상품명_분석/'.format(self.windows_user_name), title='연동할 네이버 카테고리 분석 데이터 파일을 선택해주세요')
        self.text.run('파일 이름 : {}'.format(filename.split('/')[-1].replace('.xlsx','')))

        return filename

    def SetNetworkSearch(self):
        if self.enable_network_search_btn.isChecked():
            self.enable_network_search = True
        else:
            self.enable_network_search = False

    @pyqtSlot()
    def AnalyzeBrandName(self):
        self.text.run('--Start to analyze--')
        start_time = self.text.GetTime()
        self.splited_brand_list = []
        self.ratio = pd.DataFrame()
        idx = 0
        item_idx = 0
        ratio_cnt = 0

        if len(self.category) == 0:
            file_name = self.GetFileName()
            self.category = pd.read_excel(file_name)
            self.filename = file_name

        self.target_brand_list = self.category.iloc[:, 0]

        for target in self.target_brand_list:
            splited_name = target.split(' ')
            len_splited = len(splited_name)
            self.splited_brand_list.append(' '.join(splited_name[0:round(len_splited / 2)]))

        for t1 in self.splited_brand_list:
            splited_target = t1.split(' ')
            item_name = ''
            for t2 in splited_target:
                self.ratio.loc[idx, str('키워드명')] = t2
                if self.category.iloc[item_idx, 4] != '없음':
                    item_name = self.category.iloc[item_idx, 4]
                elif self.category.iloc[item_idx, 3] != '없음':
                    item_name = self.category.iloc[item_idx, 3]
                elif self.category.iloc[item_idx, 2] != '없음':
                    item_name = self.category.iloc[item_idx, 2]
                else:
                    self.text.run('{}번째 상품명 카테고리가 없습니다. 다음으로 넘어갑니다.'.format(idx))
                    self.ratio.loc[idx, str('지정상품명')] = ''
                    continue

                self.ratio.loc[idx, str('지정상품명')] = self.target_item_list[item_idx].split('-')[0]
                for t3 in self.splited_brand_list:
                    if t2 in t3:
                        ratio_cnt += 1
                self.ratio.loc[idx, str('포함개수')] = ratio_cnt
                self.ratio.loc[idx, str('포함비율')] = (ratio_cnt / len(self.splited_brand_list)) * 100

                self.text.run('{}번째 키워드 분석이 완료되었습니다.'.format(idx + 1))
                idx += 1
                ratio_cnt = 0
            item_idx += 1

        self.ratio = self.ratio.drop_duplicates(['키워드명'], keep='last', ignore_index = True)
        self.text.run('중복된 키워드를 제거하여 총 {}개의 키워드 분석이 완료되었습니다.'.format(len(self.ratio['키워드명'])))
        ret = self.SaveFileWithDataFrame(self.ratio, self.filename.split('/')[-1].split('.')[0])

        end_time = self.text.GetTime()
        diff_time = end_time - start_time
        self.text.run('--End work--')
        self.text.run('총 소요시간은 {}초 입니다.'.format(diff_time.seconds))

    def TranslateGoogle(self, text, option):
        try:
            return self.translator.translate(text, dest=option).text
        except:
            return self.translator.translate(text, dest=option).text

    def MatchingCategory(self, query):
        ret = Result.PASS
        ct1_temp = pd.DataFrame()
        ct2_temp = pd.DataFrame()

        try:
            q = urllib.parse.quote(query)
            url = "https://openapi.naver.com/v1/search/shop?query=" + q + "&display=50"

            request = urllib.request.Request(url)
            request.add_header('X-Naver-Client-Id', self.naver_client_id)
            request.add_header('X-Naver-Client-Secret', self.naver_client_secret)

            response = urllib.request.urlopen(request)
            rr = response.read().decode('utf-8')
            category1_list = rr.split('"category1"')[1:]
            category2_list = rr.split('"category2"')[1:]

            ct1 = pd.DataFrame()
            ct2 = pd.DataFrame()

            for i in range(len(category1_list)):
                try:
                    ct1.loc[i, '카테고리'] = category1_list[i].split('",')[0].split('"')[1].split('/')[1].split('\\')[0]
                except:
                    ct1.loc[i, '카테고리'] = category1_list[i].split('",')[0].split('"')[1].split('/')[0].split('\\')[0]
            
            ct1 = ct1.drop_duplicates(['카테고리'], keep='last', ignore_index = True)
            for i in range(len(ct1)):
                ct1_temp.loc[i, '카테고리'] = ct1.loc[i, '카테고리']
                ct1_cnt = len(ct1[ct1['카테고리'] == ct1.loc[i, '카테고리']])
                ct1_temp.loc[i, '포함비율'] = (ct1_cnt / len(ct1)) * 100

            for i in range(len(category2_list)):
                try:
                    ct2.loc[i, '카테고리'] = category2_list[i].split('",')[0].split('"')[1].split('/')[1].split('\\')[0]
                except:
                    ct2.loc[i, '카테고리'] = category2_list[i].split('",')[0].split('"')[1].split('/')[0].split('\\')[0]
            
            ct2 = ct2.drop_duplicates(['카테고리'], keep='last', ignore_index = True)
            for i in range(len(ct2)):
                ct2_temp.loc[i, '카테고리'] = ct2.loc[i, '카테고리']
                ct2_cnt = len(ct2[ct2['카테고리'] == ct2.loc[i, '카테고리']])
                ct2_temp.loc[i, '포함비율'] = (ct2_cnt / len(ct2)) * 100

            category1 = ct1_temp.loc[ct1_temp['포함비율'].idxmax()]['카테고리']
            category2 = ct2_temp.loc[ct2_temp['포함비율'].idxmax()]['카테고리']
        
        except:
            ret = Result.FAIL
            category1 = ''
            category2 = ''

        return ret, category1, category2

    def ScrollPageDown(self):
        try:
            # 페이지 스크롤 최대치로 내리기
            before_h = self.driver.execute_script('return window.scrollY')
            while(True):
                self.driver.find_element(By.CSS_SELECTOR, 'body').send_keys(Keys.END)
                time.sleep(0.3)
                after_h = self.driver.execute_script('return window.scrollY')

                if after_h == before_h:
                    break
                else:
                    before_h = after_h
        except:
            return Result.FAIL
        
        return Result.PASS

    def MakeRequestAndGetResponse(self, number, headers, target_word) :
        pageingIndex = number
        params = {
            'sort':'review',
            'pagingIndex': pageingIndex,
            'pagingSize': 80,
            'viewType': 'list',
            'productSet': 'overseas',
            'deliveryFee': '',
            'deliveryTypeValue': '',
            'frm': 'NVSHPRC',
            'query': target_word,
            'iq': '',
            'eq': '',
            'xq': '',
            'minPrice': '',
            'maxPrice': '',
        }
        response = requests.get('https://search.shopping.naver.com/api/search/all', headers=headers, params=params)

        return response

    # 쓰레드 종료
    def KillThread(self):
        pid = os.getpid()
        os.kill(pid, 2)

    # UI에 텍스트 출력
    @pyqtSlot(str)
    def ConnectTextBrowser(self, print_str):
        self.textBrowser.append(print_str)
        self.textBrowser.repaint()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()
