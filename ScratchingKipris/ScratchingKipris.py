# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import uic
from PyQt5.QtCore import *
from PyQt5.QtCore import pyqtSlot

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver import ActionChains
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
import sys
import time
import datetime
import os
import pandas as pd
import threading
import subprocess
from enum import Enum
import openpyxl
import pyautogui

class SearchType(Enum):
    SINGLE = 1
    MULTIPLE = 2

class Result(Enum):
    FAIL = 0
    PASS = 1
    FINISH = 2

class NameType(Enum):
    BRAND_NAME = 0
    ITEM_NAME = 1

class Available(Enum):
    DISABLE = 0
    ENABLE = 1

# QT designer ui 파일 로드
form_class = uic.loadUiType("./driver/main_ui.ui")[0]

# UI 텍스트 출력 클래스
class TextBrowser(QThread):
    # signal을 MyWindow에 전달할 수 있게 하는 인자
    finished = pyqtSignal(str)
    now_date = ''

    @pyqtSlot(str)
    def run(self, print_str):
        self.make_log(print_str)

    @pyqtSlot(str)
    def make_log(self, print_str):
        self.now_time = datetime.datetime.now()
        self.now_date = self.now_time.strftime('[%Y-%m-%d %H:%M:%S]  ') + print_str
        self.finished.emit(self.now_date)   # signal MyWindow에 전달

    def GetTime(self):
        self.now_time = datetime.datetime.now()
        return self.now_time

# UI 구성 클래스
class MyWindow(QMainWindow, form_class):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.setWindowIcon(QIcon('./driver/MainImage.png'))    # UI에 구글 번역 icon 설정
        self.run_btn.clicked.connect(self.Run)  # 검색 버튼 누르면 self.Run 함수 실행
        self.process_delay = 1.5
        self.text = TextBrowser()               # UI에 text 출력 위한 객체
        self.windows_user_name = os.path.expanduser('~')
        self.refresh = False
        self.search_type = SearchType.SINGLE

        self.text.finished.connect(self.ConnectTextBrowser) # TextBrowser한테서 signal 받으면 ConnectTextBrowser 함수 실행
        self.exit_btn.clicked.connect(self.QuitProgram) # 종료 버튼 클릭하면 프로그램 종료되게끔 설정 & thread 종료
        self.enable_multiple_search_btn.clicked.connect(self.SetMultipleSearch)

        # Set admin state
        self.admin_all_btn.clicked.connect(self.SetAdminStateAll)

    # UI 창닫기 버튼 클릭하면 종료 의사 묻는 팝업창 띄우기
    def closeEvent(self, QCloseEvent): 
        ans = QMessageBox.question(self, "종료 확인", "종료하시겠습니까?",
                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if ans == QMessageBox.Yes:
            QCloseEvent.accept()
            self.KillThread()
        else:
            QCloseEvent.ignore()
    
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()
 
    def dropEvent(self, event):
        files = [u.toLocalFile() for u in event.mimeData().urls()]
        self.filename = files[0]
        self.df = pd.read_excel(self.filename)
        self.df.fillna('', inplace=True)
        self.text.run('파일 이름 : {}'.format(self.filename.split('/')[-1].replace('.xlsx','')))

    # 종료 버튼 누르면 실행되는 함수
    def QuitProgram(self):
        QCoreApplication.instance().quit
        self.KillThread()

    def SetMultipleSearch(self):
        if self.enable_multiple_search_btn.isChecked():
            self.search_type = SearchType.MULTIPLE
        else:
            self.search_type = SearchType.SINGLE

    # 검색 버튼 누르면 실행되는 Run 함수
    def Run(self):
        self.th = threading.Thread(target=self.Start)
        self.th.daemon = True
        self.th.start()

    # 파파고 URL 오픈
    @pyqtSlot()
    def OpenUrl(self):
        try:
            subprocess.Popen(r'C:\Program Files\Google\Chrome\Application\chrome.exe --remote-debugging-port=9225 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동
        except:
            subprocess.Popen(r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe --remote-debugging-port=9225 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동
        
        self.options = webdriver.ChromeOptions()
        user_agent = "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.83 Safari/537.36"
        self.options.add_argument('user-agent=' + user_agent)
        self.options.add_experimental_option("debuggerAddress", "127.0.0.1:9225")

        # 크롬 버전을 확인하여 버전이 안맞으면 자동으로 업데이트 하여 설치해주는 옵션       
        self.driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=self.options)
        self.driver.implicitly_wait(10)
        
        # 속도 향상을 위한 옵션 해제
        self.options.add_argument("disable-gpu") 
        self.options.add_argument("disable-infobars")
        self.options.add_argument("--disable-extensions")
        prefs = {'profile.default_content_setting_values': {'cookies' : 2, 'images': 2, 'plugins' : 2, 'popups': 2, 'geolocation': 2, 'notifications' : 2, 'auto_select_certificate': 2, 'fullscreen' : 2, 'mouselock' : 2, 'mixed_script': 2, 'media_stream' : 2, 'media_stream_mic' : 2, 'media_stream_camera': 2, 'protocol_handlers' : 2, 'ppapi_broker' : 2, 'automatic_downloads': 2, 'midi_sysex' : 2, 'push_messaging' : 2, 'ssl_cert_decisions': 2, 'metro_switch_to_desktop' : 2, 'protected_media_identifier': 2, 'app_banner': 2, 'site_engagement' : 2, 'durable_storage' : 2}}   
        #self.options.add_experimental_option('prefs', prefs)
        # 크롬 브라우저와 셀레니움을 사용하면서 발생되는 '시스템에 부착된 장치가 작동하지 않습니다.' 라는 크롬 브라우저의 버그를 조치하기 위한 코드. 
        self.options.add_experimental_option("excludeSwitches", ["enable-logging"])

        # 윈도우 사이즈 맥스로 키우기
        self.driver.maximize_window()
        self.driver.get('http://kdtj.kipris.or.kr/kdtj/searchLogina.do?method=loginTM')
        time.sleep(1)
        pyautogui.press('f12')
        time.sleep(2)
        pyautogui.press('f12')

        self.text.run('Kipris URL open 완료')
        self.ac = ActionChains(self.driver)  # 셀레니움 동작을 바인딩 하여 동작 할 수 있게 하는 모듈                    

        time.sleep(self.process_delay)
    
    @pyqtSlot()
    # 징동닷컴 크롤링 함수
    def Start(self):
        self.text.run('--Start work--')
        self.text.run('PGM ver : v24011301')
        self.start_time = self.text.GetTime()
        self.i = 0
        self.j = 0
        ret = Result.PASS
        # URL open
        self.OpenUrl()
        time.sleep(2)
        
        # Gather search list depending on search type
        if self.search_type == SearchType.MULTIPLE:
            self.search_list = pd.read_excel('./driver/SearchList.xlsx')
        else:
            self.search_list = pd.DataFrame()
            self.search_list.loc[0, str('상표명칭')] = self.brand_name_input.text()
            self.search_list.loc[0, str('지정상품')] = self.item_name_input.text()
        
        # Initialize admin state buttons
        self.admin_state = [0, 0, 0, 0, 0, 0, 0, 0]
        columns = ['상표명칭', '지정상품', '상표권유무']
        self.wb = openpyxl.Workbook()
        self.sheet = self.wb.active
        self.sheet.append(columns)

        for i in range(len(self.search_list)):
            brand_name = self.search_list.iloc[i][NameType.BRAND_NAME.value]
            item_name = self.search_list.iloc[i][NameType.ITEM_NAME.value]
            if i != 0:
                time.sleep(1)
                self.driver.execute_script("window.scrollTo(0, 100)")
                time.sleep(1)

            ret = self.PressSmartSearch()
            if ret == Result.FAIL:
                self.text.run('스마트검색 클릭에 실패했습니다.')
                return
            time.sleep(1)

            # Set admin state
            if i == 0:
                self.driver.find_element(By.CSS_SELECTOR, '#measure01').click()
                time.sleep(1)
                for i in range(len(self.admin_state)):
                    check_state = eval('self.admin_{}_btn'.format(i+1)).checkState()
                    if check_state == 2:
                        self.admin_state[i] = Available.ENABLE
                    else:
                        self.admin_state[i] = Available.DISABLE
                    
                    if self.admin_state[i] == Available.ENABLE:
                        elem_name = '#measure0{}'.format(i+2)
                        self.driver.find_element(By.CSS_SELECTOR, elem_name).click()
                        time.sleep(0.3)

                ret = self.PressFullySameButton()
                if ret == Result.FAIL:
                    self.text.run('완전일치검색 클릭에 실패했습니다.')
                    return
                time.sleep(1)

            ret = self.PunInBrandName(brand_name)
            if ret == Result.FAIL:
                self.text.run('상표명칭 입력에 실패했습니다.')
                return
            time.sleep(1)

            ret = self.PunInItemName(item_name)
            if ret == Result.FAIL:
                self.text.run('지정상품 입력에 실패했습니다.')
                return
            time.sleep(1)

            ret = self.PressSearchButton()
            if ret == Result.FAIL:
                self.text.run('상품 검색에 실패했습니다.')
                return
            time.sleep(5)

            # 상표권 유무
            no_found = pyautogui.locateCenterOnScreen('./driver/no_found.PNG', confidence=0.9)
            is_exist = '없음'
            if no_found != None:
                is_exist = '없음'
            else:
                is_exist = '있음'

            self.sheet.append([brand_name, item_name, is_exist])
            if self.search_type == SearchType.MULTIPLE:
                self.SaveFile('다중검색')
            else:
                self.SaveFile('{}_{}'.format(brand_name, item_name))

            self.text.run('{}, {} 검색을 완료했습니다. 결과 : 상표권 {}'.format(brand_name, item_name, is_exist))

        self.end_time = self.text.GetTime()
        diff_time = self.end_time - self.start_time
        self.text.run('--End work--')
        self.text.run('총 소요시간은 {}초 입니다.'.format(diff_time.seconds))
        self.driver.close()

    def LogIn(self):
        ac = ActionChains(self.driver)
        # Get ID/PW
        self.id = self.id_input.text()
        self.pw = self.pw_input.text()

        #self.driver.find_element(By.CSS_SELECTOR, '#container > div > div > div.box__content > div > button.button__tab.button__tab--auction').click()
        self.driver.find_element(By.CSS_SELECTOR, '#container > div > div > div.box__content > div > button.button__tab.button__tab--gmarket').click()
        time.sleep(1)

        # log-in
        self.id_box = self.driver.find_element(By.CSS_SELECTOR, "#typeMemberInputId01")
        self.pw_box = self.driver.find_element(By.CSS_SELECTOR, "#typeMemberInputPassword01")
        self.login_button = self.driver.find_element(By.CSS_SELECTOR, '#container > div > div > div.box__content > form > div.box__submit > button')
        ac.send_keys_to_element(self.id_box, self.id).send_keys_to_element(self.pw_box, self.pw).click(self.login_button).pause(2).perform()
        time.sleep(5)
        
        # 팝업창 닫기
        if len(self.driver.window_handles) != 1:
            for n in range(len(self.driver.window_handles) - 1):
                last_tab = self.driver.window_handles[-1]
                self.driver.switch_to.window(window_name=last_tab)
                self.driver.close()
                time.sleep(1)
            first_tab = self.driver.window_handles[0]
            self.driver.switch_to.window(window_name=first_tab)
            time.sleep(self.process_delay)

    def PressSmartSearch(self):
        ret = Result.PASS
        try:
            self.driver.find_element(By.CSS_SELECTOR, '#ToggleSmartFinder').click()
        except:
            ret = Result.FAIL
        
        return ret

    def PunInBrandName(self, brand_name):
        ret = Result.PASS
        try:
            input_elem = self.driver.find_element(By.CSS_SELECTOR, '#TN')
            input_elem.clear()
            time.sleep(0.1)
            self.ac.send_keys_to_element(input_elem, brand_name).pause(0.5).perform()
        except:
            ret = Result.FAIL

        return ret

    def PunInItemName(self, item_name):
        ret = Result.PASS
        try:
            input_elem = self.driver.find_element(By.CSS_SELECTOR, '#GD')
            input_elem.clear()
            time.sleep(0.1)
            self.ac.send_keys_to_element(input_elem, item_name).pause(0.5).perform()
        except:
            ret = Result.FAIL
        
        return ret

    def PressFullySameButton(self):
        ret = Result.PASS
        try:
            self.driver.find_element(By.CSS_SELECTOR, '#searchInComplatesCk').click()
        except:
            ret = Result.FAIL
        
        return ret

    def PressSearchButton(self):
        ret = Result.PASS
        try:
            self.driver.execute_script("window.scrollTo(0, 900)")
            time.sleep(1)
            self.driver.find_element(By.CSS_SELECTOR, '#btnItemizedSearch > img').click()
        except:
            ret = Result.FAIL

        return ret

    def SetAdminStateAll(self):
        if self.admin_all_btn.isChecked():
            if self.admin_1_btn.isChecked() == False:
                self.admin_1_btn.toggle()
            if self.admin_2_btn.isChecked() == False:
                self.admin_2_btn.toggle()
            if self.admin_3_btn.isChecked() == False:
                self.admin_3_btn.toggle()
            if self.admin_4_btn.isChecked() == False:
                self.admin_4_btn.toggle()
            if self.admin_5_btn.isChecked() == False:
                self.admin_5_btn.toggle()
            if self.admin_6_btn.isChecked() == False:
                self.admin_6_btn.toggle()
            if self.admin_7_btn.isChecked() == False:
                self.admin_7_btn.toggle()
            if self.admin_8_btn.isChecked() == False:
                self.admin_8_btn.toggle()
        else:
            if self.admin_1_btn.isChecked() == True:
                self.admin_1_btn.toggle()
            if self.admin_2_btn.isChecked() == True:
                self.admin_2_btn.toggle()
            if self.admin_3_btn.isChecked() == True:
                self.admin_3_btn.toggle()
            if self.admin_4_btn.isChecked() == True:
                self.admin_4_btn.toggle()
            if self.admin_5_btn.isChecked() == True:
                self.admin_5_btn.toggle()
            if self.admin_6_btn.isChecked() == True:
                self.admin_6_btn.toggle()
            if self.admin_7_btn.isChecked() == True:
                self.admin_7_btn.toggle()
            if self.admin_8_btn.isChecked() == True:
                self.admin_8_btn.toggle()

    def SaveFile(self, suffix = ''):
        ret = Result.PASS
        now_time = self.text.GetTime().strftime('%y%m%d%H')

        file_folder = '{}\\Desktop\\키프리스_결과물'.format(self.windows_user_name)
        filename = '{}\\{}'.format(file_folder, now_time + '_{}_Kipris_SearchResults.xlsx'.format(suffix))
        try:
            if not os.path.isdir(file_folder):
                os.mkdir(file_folder)
        except OSError:
            self.text.run('파일 폴더를 생성하는데 실패했습니다.')
            return 0

        self.wb.save(filename)
        #self.tb_temp.to_excel(filename, index=False)
        return 1

    # 쓰레드 종료
    def KillThread(self):
        pid = os.getpid()
        os.kill(pid, 2)

    # UI에 텍스트 출력
    @pyqtSlot(str)
    def ConnectTextBrowser(self, print_str):
        self.textBrowser.append(print_str)
        self.textBrowser.repaint()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()
