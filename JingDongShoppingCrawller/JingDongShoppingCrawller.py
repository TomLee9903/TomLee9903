# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
from tkinter import dialog
from typing import Text
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import uic
from PyQt5 import QtCore
from PyQt5.QtCore import *
from PyQt5.QtCore import pyqtSlot

from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import chromedriver_autoinstaller
import time
import datetime
import os
import pandas as pd
from PyQt5 import QtCore, QtGui, QtWidgets
import threading
import openpyxl
import shutil
import subprocess
import urllib.request
import requests
import json
import re
import tkinter
from tkinter.filedialog import askopenfilename
import pyautogui as pag
import pywinauto
import pygetwindow as gw
import pyperclip
from bs4 import BeautifulSoup

# QT designer ui 파일 로드
form_class = uic.loadUiType("./driver/main_ui.ui")[0]

# UI 텍스트 출력 클래스
class TextBrowser(QThread):
    # signal을 MyWindow에 전달할 수 있게 하는 인자
    finished = pyqtSignal(str)
    now_date = ''

    @pyqtSlot(str)
    def run(self, print_str):
        self.make_log(print_str)

    @pyqtSlot(str)
    def make_log(self, print_str):
        self.now_time = datetime.datetime.now()
        self.now_date = self.now_time.strftime('[%Y-%m-%d %H:%M:%S]  ') + print_str
        self.finished.emit(self.now_date)   # signal MyWindow에 전달

    def GetTime(self):
        self.now_time = datetime.datetime.now()
        return self.now_time

# UI 구성 클래스
class MyWindow(QMainWindow, form_class):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.cnt = 0
        self.setWindowIcon(QIcon('./driver/jingdong.jfif'))    # UI에 Naver icon 설정
        self.run_btn.clicked.connect(self.Run)  # 검색 버튼 누르면 self.Run 함수 실행
        self.process_delay = 1.5
        self.text = TextBrowser()               # UI에 text 출력 위한 객체
        self.text.finished.connect(self.ConnectTextBrowser) # TextBrowser한테서 signal 받으면 ConnectTextBrowser 함수 실행
        self.exit_btn.clicked.connect(self.QuitProgram) # 종료 버튼 클릭하면 프로그램 종료되게끔 설정 & thread 종료
        self.restart = False

    # UI 창닫기 버튼 클릭하면 종료 의사 묻는 팝업창 띄우기
    def closeEvent(self, QCloseEvent): 
        ans = QMessageBox.question(self, "종료 확인", "종료하시겠습니까?",
                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if ans == QMessageBox.Yes:
            QCloseEvent.accept()
            self.KillThread()
        else:
            QCloseEvent.ignore()
    
    # 종료 버튼 누르면 실행되는 함수
    def QuitProgram(self):
        QCoreApplication.instance().quit
        self.KillThread()

    # 검색 버튼 누르면 실행되는 Run 함수
    def Run(self):
        self.th = threading.Thread(target=self.StartCrawl)
        self.th.start()
    
    # 징동닷컴 크롤링 함수
    def StartCrawl(self):
        self.text.run('--Start work--')
        self.start_time = self.text.GetTime()
        root = tkinter.Tk()
        root.withdraw()
        self.windows_user_name = os.path.expanduser('~')
        self.filename = askopenfilename(parent=root, filetypes=[('네이버 결과물 파일', '.xlsx')], initialdir=self.windows_user_name, title='네이버 결과물 파일을 선택해주세요')
        self.tb = pd.read_excel(self.filename)
        self.columns = self.tb.columns

        if self.restart == False:
            self.OpenUrl()
        else:
            self.Restart()
        self.CrawlData()

    # 징동닷컴 URL 오픈
    @pyqtSlot()
    def OpenUrl(self):
        try:
            shutil.rmtree(r"c:\chrometemp")  #쿠키 / 캐쉬파일 삭제
        except FileNotFoundError:
            pass
        
        try:
            subprocess.Popen(r'C:\Program Files\Google\Chrome\Application\chrome.exe --remote-debugging-port=9222 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동
        except:
            subprocess.Popen(r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe --remote-debugging-port=9222 --user-data-dir="C:\chrometemp"') # 디버거 크롬 구동

        self.options = webdriver.ChromeOptions()
        self.options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
        # 크롬 버전을 확인하여 버전이 안맞으면 자동으로 업데이트 하여 설치해주는 옵션
        chrome_ver = chromedriver_autoinstaller.get_chrome_version().split('.')[0]
        try:
            self.driver = webdriver.Chrome(f'./{chrome_ver}/chromedriver.exe', options=self.options)
        except:
            chromedriver_autoinstaller.install(True)
            self.driver = webdriver.Chrome(f'./{chrome_ver}/chromedriver.exe', options=self.options)
        self.driver.implicitly_wait(10)

        # 속도 향상을 위한 옵션 해제
        self.options.add_argument("disable-gpu") 
        self.options.add_argument("disable-infobars")
        self.options.add_argument("--disable-extensions")
        prefs = {'profile.default_content_setting_values': {'cookies' : 2, 'images': 2, 'plugins' : 2, 'popups': 2, 'geolocation': 2, 'notifications' : 2, 'auto_select_certificate': 2, 'fullscreen' : 2, 'mouselock' : 2, 'mixed_script': 2, 'media_stream' : 2, 'media_stream_mic' : 2, 'media_stream_camera': 2, 'protocol_handlers' : 2, 'ppapi_broker' : 2, 'automatic_downloads': 2, 'midi_sysex' : 2, 'push_messaging' : 2, 'ssl_cert_decisions': 2, 'metro_switch_to_desktop' : 2, 'protected_media_identifier': 2, 'app_banner': 2, 'site_engagement' : 2, 'durable_storage' : 2}}   
        self.options.add_experimental_option('prefs', prefs)
        # 크롬 브라우저와 셀레니움을 사용하면서 발생되는 '시스템에 부착된 장치가 작동하지 않습니다.' 라는 크롬 브라우저의 버그를 조치하기 위한 코드. 
        self.options.add_experimental_option("excludeSwitches", ["enable-logging"])

        # 윈도우 사이즈 맥스로 키우기
        self.driver.maximize_window()
        self.driver.get('https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fglobal.jd.com%2F')
        self.text.run('징동닷컴 URL open 완료')

        time.sleep(self.process_delay)
        self.Login()

    def Login(self):
        ac = ActionChains(self.driver)
        WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#content > div.login-wrap > div.w > div > div.login-tab.login-tab-r > a'))).click()
        time.sleep(self.process_delay)
        id = self.id_info.text()
        pw = self.password_info.text()
        try:
            try:
                self.driver.find_element_by_css_selector('#formlogin > div.item.item-fore1 > span').click()
            except:
                pass
            self.id_box = self.driver.find_element_by_css_selector("#loginname");
            self.pw_box = self.driver.find_element_by_css_selector("#nloginpwd");
            self.login_button = self.driver.find_element_by_css_selector('#loginsubmit');
            ac.send_keys_to_element(self.id_box, id).send_keys_to_element(self.pw_box, pw).click(self.login_button).perform()
        except:
            self.main_dis = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#react-root > section > main > section')))
            print(self.main_dis)

    # 징동닷컴 크롤링 함수
    def CrawlData(self):
        self.login_xpath = '//*[@id="banner-bg"]'
        if self.restart == True:
            self.Login()
        result_header = list(pd.read_excel('./driver/결과양식.xlsx'))
        self.ac = ActionChains(self.driver)  # 셀레니움 동작을 바인딩 하여 동작 할 수 있게 하는 모듈

        # 로그인 됐는지 확인하는 명령
        try:
            WebDriverWait(self.driver, 100).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#key')))
        except:
            self.text.run('로그인에 실패했습니다.')
            self.restart = True
            return 0
        
        # 검색 버튼 클릭
        self.ClickSearchButton()
        item_len = len(self.tb['이미지이름'])
        self.i = 0
        while self.i < item_len:
#        for i in range(item_len):
            # 카메라 버튼 클릭
            try:
                WebDriverWait(self.driver, 100).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#search-img-upload'))).click()
            except:
                self.text.run('카메라버튼 클릭에 실패했습니다.')
                self.restart = True
                return 0
            time.sleep(self.process_delay)

            # 이미지 넣어주기
            image_path_tb = list(self.tb['이미지저장경로'])
            image_name_tb = list(self.tb['이미지이름'])
            image_path = image_path_tb[self.i].split(image_name_tb[self.i])[0]
            win = gw.getWindowsWithTitle('Chrome')[0] # 윈도우 타이틀에 Chrome 이 포함된 모든 윈도우 수집, 리스트로 리턴
            if win.isActive == False:
                pywinauto.application.Application().connect(handle=win._hWnd).top_window().set_focus()
            win.activate() #윈도우 활성화
            time.sleep(self.process_delay)
            pag.click(win.left + 574, win.top + 65) # 해당 윈도우의 path 클릭
            time.sleep(self.process_delay)
            pyperclip.copy(image_path)
            pag.hotkey('ctrl', 'v')
            time.sleep(self.process_delay)
            pag.press('enter')

            pag.click(win.left + 352, win.top + 530) # 해당 윈도우의 파일 이름 클릭
            pyperclip.copy(image_name_tb[self.i] + '.jpg')
            time.sleep(self.process_delay)
            pag.hotkey('ctrl', 'v')

            time.sleep(self.process_delay)
            pag.click(win.left + 749, win.top + 560) # 해당 윈도우의 열기 클릭

            # 징동닷컴검색결과주소
            try:
                WebDriverWait(self.driver, 100).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#imageSearchWrap > div > div > div > div > ul')))
            except:
                try:
                    self.driver.find_element_by_xpath(self.login_xpath)
                    self.Login()
                    self.text.run('재로그인을 실시했습니다.')
                    self.ClickSearchButton()
                    continue
                except:
                    self.text.run('이미지 검색에 실패했습니다.')
                    self.restart = True
                    return 0
            time.sleep(3)
            # 이미지가 징동닷컴에서 찾을 수 없을 때
            if self.i != 0:
                if self.driver.current_url == self.tb[self.columns[12]][self.i - 1]:
                    self.text.run('징동닷컴에서 해당 아이템을 찾을 수 없습니다. 다음 이미지로 넘어갑니다.')
                    self.i += 1
                    continue
           
            search_url = self.driver.current_url
            self.tb[self.columns[12]][self.i] = search_url
            time.sleep(1)

            # 페이지 스크롤 내리기
            before_h = self.driver.execute_script('return window.scrollY')
            while(True):
                self.driver.find_element_by_css_selector('body').send_keys(Keys.END)
                time.sleep(1)
                after_h = self.driver.execute_script('return window.scrollY') 

                if after_h == before_h:
                    break
                else:
                    before_h = after_h

            time.sleep(self.process_delay)
            title_list = []
            review_list = []
            for d in range(1, 61):
                try:
                    title_list.append(WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.XPATH, '//*[@id="plist"]/ul/li[{}]/div/div[4]/a'.format(d)))).text)
                    review_temp = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.XPATH, '//*[@id="plist"]/ul/li[{}]/div/div[5]'.format(d)))).text
                    if '万' in review_temp:
                        temp = int(review_temp.replace('已有','').replace('人评价', '').replace('+', '').replace('万', '')) * 10000
                    else:
                        temp = int(review_temp.replace('已有','').replace('人评价', '').replace('+', ''))
                    review_list.append(temp)
                except:
                    try:
                        self.driver.find_element_by_xpath(self.login_xpath)
                        self.Login()
                        self.text.run('재로그인을 실시했습니다.')
                        self.ClickSearchButton()
                        continue
                    except:
                        self.text.run('게시물 리스트 획득에 실패했습니다.')
                        self.restart = True
                        return 0
            
            max_review_idx = review_list.index(max(review_list)) + 1
            time.sleep(self.process_delay)

            # 리뷰수 제일 많은 게시물 클릭
            try:
                item_block = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.XPATH, '//*[@id="plist"]/ul/li[{}]/div/div[4]/a/em'.format(str(max_review_idx)))))
                item_block.click()
            except:
                try:
                    self.driver.find_element_by_xpath(self.login_xpath)
                    self.Login()
                    self.text.run('재로그인을 실시했습니다.')
                    self.ClickSearchButton()
                    continue
                except:
                    self.text.run('게시물 클릭에 실패했습니다.')
                    self.restart = True
                    return 0
            
            # 징동닷컴검색선택링크주소
            last_tab = self.driver.window_handles[-1]
            self.driver.switch_to.window(window_name=last_tab)
            select_url = self.driver.current_url
            self.tb[self.columns[13]][self.i] = select_url
            time.sleep(self.process_delay)
            
            # 선택제품가격
            self.elem_idx = 10
            try:
                self.price = WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.CSS_SELECTOR,'body > div:nth-child({}) > div > div.itemInfo-wrap > div.summary.summary-first > div > div.summary-price.J-summary-price > div.dd > span.p-price'.format(str(self.elem_idx))))).text.replace("￥", "").replace(" ", "")
            except:
                try:
                    self.elem_idx += 1
                    self.price = WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.CSS_SELECTOR,'body > div:nth-child({}) > div > div.itemInfo-wrap > div.summary.summary-first > div > div.summary-price.J-summary-price > div.dd > span.p-price'.format(str(self.elem_idx))))).text.replace("￥", "").replace(" ", "")
                except:
                    try:
                        self.driver.find_element_by_xpath(self.login_xpath)
                        self.Login()
                        self.text.run('재로그인을 실시했습니다.')
                        self.ClickSearchButton()
                        continue
                    except:
                        self.text.run('가격정보를 가져오는데 실패했습니다.')
                        self.restart = True
                        return 0
            self.tb[self.columns[14]][self.i] = float(self.price)

            # 상품제목
            try:
                title = WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.CSS_SELECTOR,'body > div:nth-child({}) > div > div.itemInfo-wrap > div.sku-name'.format(str(self.elem_idx))))).text
            except:
                try:
                    self.elem_idx += 1
                    title = WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.CSS_SELECTOR,'body > div:nth-child({}}) > div > div.itemInfo-wrap > div.sku-name'.format(str(self.elem_idx))))).text
                except:
                    try:
                        self.driver.find_element_by_xpath(self.login_xpath)
                        self.Login()
                        self.text.run('재로그인을 실시했습니다.')
                        self.ClickSearchButton()
                        continue
                    except:
                        self.text.run('상품제목을 가져오는데 실패했습니다.')
                        self.restart = True
                        return 0
            self.tb[self.columns[15]][self.i] = title

            # 대표이미지
            try:
                img_url = WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.CSS_SELECTOR,'#spec-img'))).get_attribute('src').split('.avif')[0]
            except:
                try:
                    self.driver.find_element_by_xpath(self.login_xpath)
                    self.Login()
                    self.text.run('재로그인을 실시했습니다.')
                    self.ClickSearchButton()
                    continue
                except:
                    self.text.run('대표이미지를 가져오는데 실패했습니다.')
                    self.restart = True
                    return 0
            self.tb[self.columns[16]][self.i] = img_url

            windows_user_name = os.path.expanduser('~')
            now_time = datetime.datetime.now()
            today = now_time.strftime('%Y%m%d')  #YYYY-MM-DD
            img_folder = '{}\\Desktop\\{}_징동닷컴'.format(windows_user_name, today)
            try:
                if not os.path.isdir(img_folder):
                    os.mkdir(img_folder)
            except OSError:
                self.text.run('이미지 폴더를 생성하는데 실패했습니다.')
                break

            image_name = self.CleanText(title)
            t = urllib.request.urlretrieve(img_url, img_folder + '\\' + image_name.replace(' ','_') + '.jpg')
            
            before_h = self.driver.execute_script('return window.scrollY')
            while(True):
                self.driver.find_element_by_css_selector('body').send_keys(Keys.END)
                time.sleep(1)
                after_h = self.driver.execute_script('return window.scrollY') 

                if after_h == before_h:
                    break
                else:
                    before_h = after_h

            # 옵션1
            option1_list = []
            option1_total = []
            try:
                self.GetOption1(option1_total, option1_list)
            except:
                try:

                    self.driver.find_element_by_xpath(self.login_xpath)
                    self.Login()
                    self.text.run('재로그인을 실시했습니다.')
                    self.ClickSearchButton()
                    continue
                except:
                    self.text.run('옵션1 이미지를 가져오는데 실패했습니다.')
                    self.restart = True
                    return 0
            option1_list = '\n'.join(option1_list)
            option1_total = '\n'.join(option1_total)

            self.tb[self.columns[17]][self.i] = option1_list
            self.tb[self.columns[19]][self.i] = option1_total

            url = self.driver.current_url
            response = requests.get(url)
            html = response.text
            soup = BeautifulSoup(html, 'html.parser')

            # 상세페이지
            try:
                try:
                    detail_imgs = []
                    for d1 in range(4):
                        img_temp = WebDriverWait(self.driver, 0.1).until(EC.presence_of_element_located((By.XPATH, '//*[@id="J-detail-content"]/p[1]/img[{}]'.format(d1 + 1)))).get_attribute('src')
                        detail_imgs.append(img_temp)                                                                
                    for d2 in range(4):
                        img_temp = WebDriverWait(self.driver, 0.1).until(EC.presence_of_element_located((By.XPATH, '//*[@id="J-detail-content"]/p[2]/img[{}]'.format(d2 + 1)))).get_attribute('src')
                        detail_imgs.append(img_temp)
                    for d3 in range(4):
                        img_temp = WebDriverWait(self.driver, 0.1).until(EC.presence_of_element_located((By.XPATH, '//*[@id="J-detail-content"]/p[3]/img[{}]'.format(d3 + 1)))).get_attribute('src')
                        detail_imgs.append(img_temp)
                    for d4 in range(4):
                        img_temp = WebDriverWait(self.driver, 0.1).until(EC.presence_of_element_located((By.XPATH, '//*[@id="J-detail-content"]/p[4]/img[{}]'.format(d4 + 1)))).get_attribute('src')
                        detail_imgs.append(img_temp)
                except:
                    pass
            except:
                try:
                    self.driver.find_element_by_xpath(self.login_xpath)
                    self.Login()
                    self.text.run('재로그인을 실시했습니다.')
                    self.ClickSearchButton()
                    continue
                except:
                    self.text.run('상세페이지 이미지를 가져오는데 실패했습니다.')
                    self.restart = True
                    return 0

            detail_imgs = '\n'.join(detail_imgs)
            self.tb[self.columns[20]][self.i] = detail_imgs

            if self.i == item_len - 1:
                self.text.run('{}번째 아이템 크롤링 중'.format(self.i + 1))
                self.text.run('마지막 아이템입니다.')
                self.text.run('크롤링이 완료되었습니다.')
                break
            else:
                self.text.run('{}번째 아이템 크롤링 중'.format(self.i + 1))

            self.tb.to_excel(self.filename, index=False)
            
            self.driver.close()
            first_tab = self.driver.window_handles[0]
            self.driver.switch_to.window(window_name=first_tab)
            time.sleep(self.process_delay)
            self.i += 1

        # 크롬드라이버 종료
        self.end_time = self.text.GetTime()
        diff_time = self.end_time - self.start_time
        self.text.run('--End work--')
        self.text.run('총 소요시간은 {}초 입니다.'.format(diff_time.seconds))
        self.restart = True
        return 1
    
    def GetOption1(self, option1_total, option1_list):
        choose_idx = 1
        max_price = 0
        option1_total = WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.CSS_SELECTOR,'#choose-attrs'))).text.split('\n')
        price_css = 'body > div:nth-child({}) > div > div.itemInfo-wrap > div.summary.summary-first > div > div.summary-price.J-summary-price > div.dd > span.p-price'.format(str(self.elem_idx))
        for n in range(1, len(option1_total)):
            try:
                WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.XPATH, '//*[@id="choose-attr-{}"]/div[2]/div[{}]/a'.format(str(choose_idx), str(n))))).click()
            except:
                choose_idx += 1
                WebDriverWait(self.driver, 1).until(EC.presence_of_element_located((By.XPATH, '//*[@id="choose-attr-{}"]/div[2]/div[{}]/a'.format(str(choose_idx), str(n))))).click()
            
            img_xpath = '//*[@id="choose-attr-{}"]/div[2]/div[{}]/a/img'.format(str(choose_idx), str(n))
            try:
                price_temp = WebDriverWait(self.driver, 5).until(EC.presence_of_element_located((By.CSS_SELECTOR, price_css))).text.replace("￥", "").replace(" ", "")
            except:
                price_css = 'body > div:nth-child(11) > div > div.itemInfo-wrap > div.summary.summary-first > div > div.summary-price.J-summary-price > div.dd > span'.format(str(self.elem_idx))
                price_temp = WebDriverWait(self.driver, 5).until(EC.presence_of_element_located((By.CSS_SELECTOR, price_css))).text.replace("￥", "").replace(" ", "")
            
            try:
                temp = self.driver.find_element_by_xpath(img_xpath).get_attribute('src').split('.avif')[0]
            except:
                img_xpath = '//*[@id="spec-img"]'
                temp = self.driver.find_element_by_xpath(img_xpath).get_attribute('src').split('.avif')[0]

            option1_list.append(temp)
            option1_total[n] += '/' + price_temp
            max_price = float(self.price) + float(price_temp)
            if max_price > float(self.price) * 4:
                self.text.run('{}번째 아이템의 옵션가격이 본품 금액의 300%를 초과했습니다. 다음 아이템으로 넘어갑니다'.format(self.i + 1))
                break
            if n == 20:
                self.text.run('{}번째 아이템의 옵션 갯수를 20개로 한정합니다.'.format(self.i + 1))
                break
            
    def ClickSearchButton(self):
        try:
            search_tab = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#key')))
            search_click = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#search-btn')))
            text = 'aa'
            self.ac.move_to_element(search_tab).click().pause(2).send_keys(text).pause(2).move_to_element(search_click).click().perform()
        except:
            self.text.run('검색버튼 클릭에 실패했습니다.')
            self.restart = True
            return 0

        time.sleep(self.process_delay)

    def isRepeat(self, previousItemList, itemList) :
    
        #같은 값을 응답받으면 True 리턴
        if previousItemList['shoppingResult']['products'][0]['productName'] == itemList['shoppingResult']['products'][0]['productName']:
            self.text.run('중복된 페이지 크롤링을 시도했습니다. 크롤링을 종료합니다.')
            return True
        #아니면 False 리턴
        return False

    def MakeRequestAndGetResponse(self, number, headers) :
        pageingIndex = number

        response = requests.get('https://search.jd.com/adword?source=search_pc&skuids=', headers=headers)

        return response

    def CleanText(self, inputString):
        text_rmv = re.sub('[-=+,#/\?:^.@*\"※~ㆍ!』‘|\(\)\[\]`\'…》\”\“\’·]', ' ', inputString)
        return text_rmv

    # 리뷰 타입 선택
    def SetReviewType(self):
        if self.amt_review.isChecked():
            self.review_type = 0
        elif self.good_review.isChecked():
            self.review_type = 1

    # 크롤링 재시작
    def Restart(self):
        self.driver.get('https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fglobal.jd.com%2F')
        self.text.run('징동닷컴 URL re-open 완료')
        time.sleep(self.process_delay)

    # 쓰레드 종료
    def KillThread(self):
        pid = os.getpid()
        os.kill(pid, 2)

    # UI에 텍스트 출력
    @pyqtSlot(str)
    def ConnectTextBrowser(self, print_str):
        self.textBrowser.append(print_str)
        self.textBrowser.repaint()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()
